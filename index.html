<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>민지의 테트리스</title>
    <style>
        /* ------------------ CSS Styling ------------------ */
        body {
            font-family: 'Malgun Gothic', Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #333;
            color: #fff;
        }

        #game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            border: 4px solid #4CAF50; /* 테두리 강조 */
            background-color: #222;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #tetris-canvas {
            border: 2px solid #777;
            background-color: #000;
        }

        #info {
            width: 180px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
        }

        h2 {
            color: #4CAF50;
            margin-top: 0;
            text-align: center;
        }

        #score-label, #next-block-label {
            font-size: 1.1em;
            font-weight: bold;
            color: #aaa;
            margin-bottom: 5px;
        }

        #score {
            font-size: 1.5em;
            color: #fff;
        }

        #next-block-canvas {
            border: 1px solid #777;
            background-color: #111;
            margin-top: 5px;
        }

        #start-button {
            padding: 12px 15px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: auto;
            transition: background 0.2s;
        }

        #start-button:hover {
            background-color: #45a049;
        }

        .game-over-text {
            color: #ff4d4d;
            font-size: 1.8em;
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            display: none; 
            text-shadow: 2px 2px #000;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="tetris-canvas" width="200" height="400"></canvas>
        
        <div id="info">
            <h2>민지의 테트리스</h2>
            <hr style="width:100%; border:0; border-top:1px solid #444;">
            
            <div>
                <p id="score-label">SCORE</p>
                <span id="score">0</span>
            </div>

            <div>
                <p id="next-block-label">NEXT BLOCK</p>
                <canvas id="next-block-canvas" width="80" height="80"></canvas>
            </div>

            <p class="game-over-text" id="game-over-message">GAME OVER</p>
            <button id="start-button">게임 시작</button>
        </div>
    </div>

    <script>
        /* ------------------ JavaScript Game Logic ------------------ */
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('tetris-canvas');
            const ctx = canvas.getContext('2d');
            const nextCanvas = document.getElementById('next-block-canvas');
            const nextCtx = nextCanvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const startButton = document.getElementById('start-button');
            const gameOverMessage = document.getElementById('game-over-message');

            const ROWS = 20;
            const COLS = 10;
            const BLOCK_SIZE = canvas.width / COLS;

            let board = [];
            let currentBlock;
            let nextBlock;
            let score = 0;
            let gameOver = true;
            let dropInterval;
            let drawInterval;
            const DROP_SPEED = 1000;

            const TETROMINOES = [
                { shape: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], color: '#00f0f0' }, // I (Cyan)
                { shape: [[1,1], [1,1]], color: '#f0f000' }, // O (Yellow)
                { shape: [[0,1,0], [1,1,1], [0,0,0]], color: '#a000f0' }, // T (Purple)
                { shape: [[0,1,1], [1,1,0], [0,0,0]], color: '#00f000' }, // S (Green)
                { shape: [[1,1,0], [0,1,1], [0,0,0]], color: '#f00000' }, // Z (Red)
                { shape: [[1,0,0], [1,1,1], [0,0,0]], color: '#0000f0' }, // J (Blue)
                { shape: [[0,0,1], [1,1,1], [0,0,0]], color: '#f0a000' }  // L (Orange)
            ];

            function createBoard() {
                for (let r = 0; r < ROWS; r++) {
                    board[r] = [];
                    for (let c = 0; c < COLS; c++) {
                        board[r][c] = 0;
                    }
                }
            }

            function getNewBlock() {
                const randIndex = Math.floor(Math.random() * TETROMINOES.length);
                const blockType = TETROMINOES[randIndex];
                
                return {
                    shape: blockType.shape,
                    color: blockType.color,
                    x: Math.floor(COLS / 2) - Math.floor(blockType.shape[0].length / 2),
                    y: 0 
                };
            }

            function drawBlock(x, y, color, context, size) {
                if (color === 0) return;

                context.fillStyle = color;
                context.fillRect(x * size, y * size, size, size);
                
                context.strokeStyle = 'rgba(0,0,0,0.3)';
                context.strokeRect(x * size, y * size, size, size);
                
                // 광택 효과 추가
                context.fillStyle = 'rgba(255,255,255,0.1)';
                context.fillRect(x * size, y * size, size, size / 2);
            }

            function drawBoard() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        drawBlock(c, r, board[r][c], ctx, BLOCK_SIZE);
                    }
                }
            }

            function drawCurrentBlock() {
                if (!currentBlock) return;
                const { shape, color, x, y } = currentBlock;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            drawBlock(x + c, y + r, color, ctx, BLOCK_SIZE);
                        }
                    }
                }
            }
            
            function drawNextBlock() {
                if (!nextBlock) return;
                const nextShape = nextBlock.shape;
                const nextColor = nextBlock.color;
                nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
                
                const NEXT_BLOCK_SIZE = 20; 
                const offsetX = (nextCanvas.width - (nextShape[0].length * NEXT_BLOCK_SIZE)) / 2;
                const offsetY = (nextCanvas.height - (nextShape.length * NEXT_BLOCK_SIZE)) / 2;

                for (let r = 0; r < nextShape.length; r++) {
                    for (let c = 0; c < nextShape[r].length; c++) {
                        if (nextShape[r][c]) {
                            drawBlock(offsetX / NEXT_BLOCK_SIZE + c, offsetY / NEXT_BLOCK_SIZE + r, nextColor, nextCtx, NEXT_BLOCK_SIZE);
                        }
                    }
                }
            }

            function checkCollision(shape, x, y) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const newX = x + c;
                            const newY = y + r;
                            if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                            if (newY < 0) continue; 
                            if (board[newY] && board[newY][newX] !== 0) return true;
                        }
                    }
                }
                return false;
            }

            function moveBlock(dx, dy) {
                const newX = currentBlock.x + dx;
                const newY = currentBlock.y + dy;
                if (!checkCollision(currentBlock.shape, newX, newY)) {
                    currentBlock.x = newX;
                    currentBlock.y = newY;
                    return true;
                }
                return false;
            }

            function rotate() {
                const shape = currentBlock.shape;
                const N = shape.length;
                const newShape = [];
                for(let r = 0; r < N; r++) {
                    newShape[r] = [];
                    for(let c = 0; c < N; c++) {
                        newShape[r][c] = shape[N - 1 - c][r];
                    }
                }
                if (!checkCollision(newShape, currentBlock.x, currentBlock.y)) {
                    currentBlock.shape = newShape;
                }
            }

            function lockBlock() {
                const { shape, color, x, y } = currentBlock;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            if (y + r < 0) {
                                endGame();
                                return;
                            }
                            board[y + r][x + c] = color;
                        }
                    }
                }
                checkLines();
                currentBlock = nextBlock;
                nextBlock = getNewBlock();
                drawNextBlock();
                if (checkCollision(currentBlock.shape, currentBlock.x, currentBlock.y)) {
                    endGame();
                }
            }

            function checkLines() {
                let linesCleared = 0;
                for (let r = ROWS - 1; r >= 0; r--) {
                    const isFull = board[r].every(cell => cell !== 0);
                    if (isFull) {
                        for (let r2 = r; r2 > 0; r2--) {
                            board[r2] = [...board[r2 - 1]];
                        }
                        board[0] = new Array(COLS).fill(0); 
                        linesCleared++;
                        r++; 
                    }
                }
                if (linesCleared > 0) {
                    score += linesCleared * 100 * linesCleared; 
                    scoreElement.textContent = score;
                }
            }

            function dropBlock() {
                if (!moveBlock(0, 1)) {
                    lockBlock();
                }
            }

            function update() {
                drawBoard();
                drawCurrentBlock();
            }
            
            function handleKeydown(e) {
                if (gameOver) return;
                switch (e.key) {
                    case 'ArrowLeft': moveBlock(-1, 0); break;
                    case 'ArrowRight': moveBlock(1, 0); break;
                    case 'ArrowDown': 
                        dropBlock();
                        clearInterval(dropInterval);
                        dropInterval = setInterval(dropBlock, DROP_SPEED); 
                        break;
                    case 'ArrowUp':
                    case ' ': rotate(); break;
                }
                update();
            }

            function startGame() {
                if (!gameOver) return;
                createBoard();
                score = 0;
                scoreElement.textContent = score;
                gameOver = false;
                gameOverMessage.style.display = 'none';
                startButton.textContent = "다시 시작";

                currentBlock = getNewBlock();
                nextBlock = getNewBlock();
                drawNextBlock();
                
                if (dropInterval) clearInterval(dropInterval);
                if (drawInterval) clearInterval(drawInterval);
                
                dropInterval = setInterval(dropBlock, DROP_SPEED);
                drawInterval = setInterval(update, 1000 / 60);
            }

            function endGame() {
                gameOver = true;
                clearInterval(dropInterval);
                clearInterval(drawInterval);
                gameOverMessage.style.display = 'block';
            }
            
            document.addEventListener('keydown', handleKeydown);
            startButton.addEventListener('click', startGame);

            createBoard();
            drawBoard();
            nextBlock = getNewBlock();
            drawNextBlock();
        });
    </script>
</body>
</html>
